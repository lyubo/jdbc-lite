package org.sqlite.jdbc;

import java.sql.Array;
import java.sql.Blob;
import java.sql.CallableStatement;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.NClob;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLClientInfoException;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Savepoint;
import java.sql.Statement;
import java.sql.Struct;
import java.util.Map;
import java.util.Properties;

import org.sqlite.SQLite;

import com.sun.jna.Pointer;
import com.sun.jna.ptr.PointerByReference;

/**
 * A SQLiteConnection represents a session with a specific database. Within the context of a Connection, SQL statements are executed and results are returned.
 * 
 * @author Lyubomir Ivanov
 * @version $Id: SQLiteConnection.java $
 * @see java.sql.Connection
 */
public class SQLiteConnection implements Connection
{
  Pointer                handle   = null;
  private SQLiteMetaData metaData = null;

  /**
   * Get handle to an sqlite database
   * 
   * @see java.sql.Connection
   */
  public SQLiteConnection(String dbFilename) throws SQLException
  {
    PointerByReference pdb = new PointerByReference();
    try {
      check(SQLite.open(dbFilename, pdb));
      check(SQLite.exec(pdb.getValue(),"PRAGMA foreign_keys = ON",null,null,null));
    } finally {
      handle = pdb.getValue();
    }
  }

  /**
   * 1. A Connection object is automatically closed when it is garbage collected. (1.5)
   * 
   * @see java.sql.Connection#close()
   */
  @Override
  protected void finalize() throws Throwable
  {
    close();
    super.finalize();
  }

  /**
   * <ul>
   * <li>1. Calling the method close on a Connection object that is already closed is a no-op. (1.5)</li>
   * <li>2. If the close method is called and there is an active transaction, the results are implementation-defined. (1.6)</li>
   * </ul>
   * 
   * @see java.sql.Connection#close()
   */
  public void close()
  {
    if (handle != null) {
      // TODO: finalize all prepared statements and close all BLOB handles
      SQLite.close(handle);
      handle = null;
    }
  }

  /**
   * @see java.sql.Connection#isClosed()
   */
  public boolean isClosed() throws SQLException
  {
    return handle != null;
  }

  /**
   * @see java.sql.Connection#createStatement()
   */
  public Statement createStatement() throws SQLException
  {
    return new SQLiteStatement(this);
  }

  /**
   * @see java.sql.Connection#createStatement(int, int)
   */
  public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException
  {
    checkStatementFlags(resultSetType, resultSetConcurrency, ResultSet.CLOSE_CURSORS_AT_COMMIT);
    return createStatement();
  }

  /**
   * @see java.sql.Connection#createStatement(int, int, int)
   */
  public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException
  {
    checkStatementFlags(resultSetType, resultSetConcurrency, resultSetHoldability);
    return createStatement();
  }

  /**
   * @see java.sql.Connection#prepareStatement(java.lang.String)
   */
  public PreparedStatement prepareStatement(String sql) throws SQLException
  {
    return new SQLiteStatement(this, sql);
  }

  /**
   * @see java.sql.Connection#prepareStatement(java.lang.String, int, int)
   */
  public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException
  {
    checkStatementFlags(resultSetType, resultSetConcurrency, ResultSet.CLOSE_CURSORS_AT_COMMIT);
    return new SQLiteStatement(this, sql);
  }

  /**
   * @see java.sql.Connection#prepareStatement(java.lang.String, int, int, int)
   */
  public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException
  {
    checkStatementFlags(resultSetType, resultSetConcurrency, resultSetHoldability);
    return new SQLiteStatement(this, sql);
  }

  public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException
  {
    return new SQLiteStatement(this, sql, autoGeneratedKeys);
  }

  public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException
  {
    throw new SQLException("Auto-generated keys for multiple number columns is not supported");
  }

  public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException
  {
    throw new SQLException("Auto-generated keys for multiple number columns is not supported");
  }

  public SQLWarning getWarnings() throws SQLException
  {
    checkConnection();
    return null;
  }

  public void clearWarnings() throws SQLException
  {
  }

  public String getCatalog() throws SQLException
  {
    return null;
  }

  public void setCatalog(String catalog) throws SQLException
  {
    // silently ignore this request. 
  }

  public DatabaseMetaData getMetaData() throws SQLException
  {
      if (metaData == null) metaData = new SQLiteMetaData(this);
      return metaData;
  }

  public int getTransactionIsolation() throws SQLException
  {
    return TRANSACTION_SERIALIZABLE;
  }

  public void setTransactionIsolation(int level) throws SQLException
  {
    // TODO: implement READ-UNCOMITTED for shared cache
  }

  public int getHoldability() throws SQLException
  {
    return ResultSet.CLOSE_CURSORS_AT_COMMIT;
  }

  public void setHoldability(int holdability) throws SQLException
  {
    if (holdability != ResultSet.CLOSE_CURSORS_AT_COMMIT) throw new SQLException("Unsupported holdability mode","",SQLite.SQLITE_MISUSE);
  }
  
  public Map<String, Class<?>> getTypeMap() throws SQLException
  {
    throw new SQLException("Not implemented: getTypeMap");
  }

  public boolean isReadOnly() throws SQLException
  {
    throw new SQLException("Not implemented: isReadOnly");
  }

  public String nativeSQL(String sql) throws SQLException
  {
    throw new SQLException("Not implemented: nativeSQL");
  }

  public CallableStatement prepareCall(String sql) throws SQLException
  {
    throw new SQLException("Not implemented: prepareCall(String sql)");
  }

  public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException
  {
    throw new SQLException("Not implemented: prepareCall(String sql, int resultSetType, int resultSetConcurrency)");
  }

  public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException
  {
    throw new SQLException("Not implemented: prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability)");
  }

  public Array createArrayOf(String arg0, Object[] arg1) throws SQLException
  {
    throw new SQLException("Not implemented: createArrayOf(String arg0, Object[] arg1)");
  }

  public Blob createBlob() throws SQLException
  {
    throw new SQLException("Not implemented: createBlob()");
  }

  public Clob createClob() throws SQLException
  {
    throw new SQLException("Not implemented: createClob()");
  }

  public Struct createStruct(String arg0, Object[] arg1) throws SQLException
  {
    throw new SQLException("Not implemented: createStruct(String arg0, Object[] arg1)");
  }

  public Properties getClientInfo() throws SQLException
  {
    throw new SQLException("Not implemented: getClientInfo()");
  }

  public String getClientInfo(String arg0) throws SQLException
  {
    throw new SQLException("Not implemented: getClientInfo(String arg0)");
  }

  public boolean isValid(int arg0) throws SQLException
  {
    throw new SQLException("Not implemented: isValid(int arg0");
  }

  /**
   * @see java.sql.Connection#getAutoCommit()
   */
  public boolean getAutoCommit() throws SQLException
  {
    return SQLite.get_autocommit(handle) > 0;
  }

  /**
   * @see java.sql.Connection#setAutoCommit(boolean)
   */
  public void setAutoCommit(boolean autoCommit) throws SQLException
  {
    boolean modeAutoCommit = SQLite.get_autocommit(handle) > 0;
    if (modeAutoCommit == autoCommit) return;

    if (modeAutoCommit) {
      // auto-commit=false so we have to put database in non-autocommit mode
      check(SQLite.exec(handle, "BEGIN;", null, null, null));
    } else {
      // auto-commit=true so we have to put database in autocommit mode
      check(SQLite.exec(handle, "COMMIT;", null, null, null));
    }
  }

  /**
   * 1. Throws SQLException if this Connection object is in auto-commit mode (1.5)
   * 
   * @see java.sql.Connection#commit()
   */
  public void commit() throws SQLException
  {
    boolean modeAutoCommit = SQLite.get_autocommit(handle) > 0;
    if (modeAutoCommit) throw new SQLException("Can't call commit() when in AutoCommit mode");
    check(SQLite.exec(handle, "COMMIT;BEGIN;", null, null, null));
  }

  /**
   * 1. Throws SQLException if this Connection object is in auto-commit mode (1.5)
   * 
   * @see java.sql.Connection#rollback()
   */
  public void rollback() throws SQLException
  {
    boolean modeAutoCommit = SQLite.get_autocommit(handle) > 0;
    if (modeAutoCommit) throw new SQLException("Can't call rollback() when in AutoCommit mode");
    check(SQLite.exec(handle, "ROLLBACK;BEGIN;", null, null, null));
  }

  public void setReadOnly(boolean readOnly) throws SQLException
  {
    throw new SQLException("Not implemented: setReadOnly");
  }

  public void setTypeMap(Map<String, Class<?>> map) throws SQLException
  {
    throw new SQLException("Not implemented: setTypeMap");
  }

  // ***************************************************************************
  // *** Functionality not supported by SQLite
  // ***************************************************************************
  public void rollback(Savepoint savepoint) throws SQLException
  {
    throw new SQLException("Feature 'Savepoints' is not supported.");
  }

  public Savepoint setSavepoint() throws SQLException
  {
    throw new SQLException("Feature 'Savepoints' is not supported.");
  }

  public Savepoint setSavepoint(String name) throws SQLException
  {
    throw new SQLException("Feature 'Savepoints' is not supported.");
  }

  public void releaseSavepoint(Savepoint savepoint) throws SQLException
  {
    throw new SQLException("Feature 'Savepoints' is not supported.");
  }

  // ***************************************************************************
  // *** Private/protected methods
  // ***************************************************************************
  protected void checkConnection() throws SQLException
  {
    if (handle == null) throw new SQLException("No open database.");
  }

  protected int check(int result) throws SQLException
  {
    // TODO:
    switch (result) {
      case SQLite.SQLITE_OK:
      case SQLite.SQLITE_ROW:
      case SQLite.SQLITE_DONE:
        break;

      // case SQLITE_ABORT:trow new Abort(); = 4; // Callback routine requested an abort
      // int SQLITE_INTERRUPT = 9; // Operation terminated by sqlite3_interrupt()
      // int SQLITE_BUSY = 5; // The database file is locked
      // int SQLITE_LOCKED = 6; // A table in the database is locked

      // case SQLiteAPI.SQLITE_MISUSE:

      default:
        throw new SQLException(SQLite.errmsg(handle), "", result);
    }
    return result;
  }

  private void checkStatementFlags(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException
  {
    if (resultSetType != ResultSet.TYPE_FORWARD_ONLY) {
      throw new SQLException("Scrolling cursors are not supported.", "", SQLite.SQLITE_MISUSE);
    }
    if (resultSetConcurrency != ResultSet.CONCUR_READ_ONLY) {
      throw new SQLException("Updatable cursors are not supported.", "", SQLite.SQLITE_MISUSE);
    }
    if (resultSetHoldability == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
      throw new SQLException("Holding cursors over commit is not supported.", "", SQLite.SQLITE_MISUSE);
    }
  }

  public boolean isWrapperFor(Class<?> arg0) throws SQLException
  {
    throw new SQLException("Not implemented: isWrapperFor");
  }

  public <T> T unwrap(Class<T> arg0) throws SQLException
  {
    throw new SQLException("Not implemented: unwrap");
  }

  public NClob createNClob() throws SQLException
  {
    throw new SQLException("Not implemented: createNClob");
  }

  public SQLXML createSQLXML() throws SQLException
  {
    throw new SQLException("Not implemented: createSQLXML");
  }

  public void setClientInfo(Properties arg0) throws SQLClientInfoException
  {
    throw new SQLClientInfoException();
  }

  public void setClientInfo(String arg0, String arg1) throws SQLClientInfoException
  {
    throw new SQLClientInfoException();
  }

}
