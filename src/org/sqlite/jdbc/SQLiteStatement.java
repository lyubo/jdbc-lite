package org.sqlite.jdbc;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.BatchUpdateException;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.Date;
import java.sql.NClob;
import java.sql.ParameterMetaData;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.sqlite.SQLite;

import com.sun.jna.Pointer;
import com.sun.jna.ptr.PointerByReference;

public class SQLiteStatement implements PreparedStatement,ParameterMetaData
{
  private enum BindType {
    UNKNOWN(String.class, Types.VARCHAR, "VARCHAR") {
    },
    INT(Integer.class, Types.INTEGER, "INTEGER") {
    },
    BOOL(Boolean.class, Types.BOOLEAN, "INTEGER") {
    },
    LONG(Long.class, Types.BIGINT, "BIGINT") {
    },
    DATE(Date.class, Types.DATE, "DATE") {
    },
    TEXT(String.class, Types.LONGVARCHAR, "TEXT");

    public Class<?> clazz;
    public int      sqlType;
    public String   sqlTypeName;

    BindType(Class<?> claszz, int sqlType, String sqlTypeName)
    {
      this.clazz = claszz;
      this.sqlType = sqlType;
      this.sqlTypeName = sqlTypeName;
    }

  };

  private static Map<Class<?>, BindType> TYPE_MAP = new HashMap<Class<?>, BindType>();
  static {
    TYPE_MAP.put(java.lang.Integer.class, BindType.INT);
    TYPE_MAP.put(java.lang.Long.class, BindType.LONG);
    TYPE_MAP.put(java.lang.String.class, BindType.TEXT);
    TYPE_MAP.put(java.util.Date.class, BindType.DATE);
    TYPE_MAP.put(java.sql.Date.class, BindType.DATE);
    TYPE_MAP.put(java.sql.Time.class, BindType.DATE);
    TYPE_MAP.put(java.sql.Timestamp.class, BindType.DATE);
  }
  
  private final static List<ColumnDef> getGeneratedKeys_columnDefs = new ArrayList<ColumnDef>();
  static {
    getGeneratedKeys_columnDefs.add(new ColumnDef( 1,"GENERATED_KEY", "Long"));
  } 

  SQLiteConnection               connection;
  Pointer                        stmt;
  
  private String                 sql;
  private Map<Integer, ParamDef> params;
  private SQLiteResultSet        resultSet;
  private int                    updateCount;
  private boolean                escapeProcessing;
  private boolean                fetchGeneratedKey;
  private Long                   generatedKey;

  public SQLiteStatement(SQLiteConnection pConnection)
  {
    connection = pConnection;
    sql = null;
    params = new HashMap<Integer, ParamDef>();
    stmt = null;
    resultSet = null;
    updateCount = -1;
    escapeProcessing = false;
  }

  public SQLiteStatement(SQLiteConnection pConnection, String pSQL) throws SQLException
  {
    this(pConnection);
    sql = pSQL;
    internalPrepare();
  }

  public SQLiteStatement(SQLiteConnection pConnection, String pSQL,int autoGeneratedKeys) throws SQLException
  {
    this(pConnection);
    sql = pSQL;
    fetchGeneratedKey = autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS;
    internalPrepare();
  }

  /**
   * 1. A Statement object is automatically closed when it is garbage collected. (1.5)
   * 
   * @see java.sql.Statement#close()
   */
  @Override
  protected void finalize() throws Throwable
  {
    close();
    super.finalize();
  }

  // ***************************************************************************
  // *** Implementation of java.sql.Statement interface
  // ***************************************************************************

  /**
   * @see java.sql.Statement#close()
   */
  public void close() throws SQLException
  {
    if (stmt != null) {
      if (resultSet != null) {
        resultSet.close();
        resultSet = null;
      }
      SQLite.finalize(stmt);
      stmt = null;
    }
  }

  /**
   * @see java.sql.Statement#getConnection()
   */
  public Connection getConnection() throws SQLException
  {
    return connection;
  }

  /**
   * @see java.sql.Statement#setEscapeProcessing(boolean)
   */
  public void setEscapeProcessing(boolean pEscapeProcessing) throws SQLException
  {
    escapeProcessing = pEscapeProcessing;
  }

  public boolean execute(String pSql) throws SQLException
  {
    sql = pSql;
    fetchGeneratedKey = false;
    internalPrepare();
    return internalExecute();
  }

  public boolean execute(String pSql, int autoGeneratedKeys) throws SQLException
  {
    sql = pSql;
    fetchGeneratedKey = autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS;
    internalPrepare();
    return internalExecute();
  }

  public boolean execute(String pSql, int[] columnIndexes) throws SQLException
  {
    throw new SQLException("Not implemented: execute(String sql, int[] columnIndexes)");
  }

  public boolean execute(String pSql, String[] columnNames) throws SQLException
  {
    throw new SQLException("Not implemented: execute(String sql, String[] columnNames)");
  }

  public ResultSet executeQuery(String pSql) throws SQLException
  {
    if (!execute(pSql)) throw new SQLException("Not a ResultSet statement");
    return resultSet;
  }

  public int executeUpdate(String pSql) throws SQLException
  {
    if (execute(pSql)) throw new SQLException("Not an update statement statement");
    return updateCount;
  }

  public int executeUpdate(String pSql, int autoGeneratedKeys) throws SQLException
  {
    if (execute(pSql,autoGeneratedKeys)) throw new SQLException("Not an update statement statement");
    return updateCount;
  }

  public int executeUpdate(String pSql, int[] columnIndexes) throws SQLException
  {
    throw new SQLException("Not implemented: executeUpdate(String sql, int[] columnIndexes)");
  }

  public int executeUpdate(String pSql, String[] columnNames) throws SQLException
  {
    throw new SQLException("Not implemented: executeUpdate(String sql, String[] columnNames)");
  }

  public boolean getMoreResults() throws SQLException
  {
    return false;
  }

  public int getUpdateCount() throws SQLException
  {
    return updateCount;
  }

  public ResultSet getResultSet() throws SQLException
  {
    return resultSet;
  }

  public void addBatch(String pSql) throws SQLException
  {
    throw new SQLException("Not implemented: addBatch(String sql)");
  }

  public void cancel() throws SQLException
  {
    throw new SQLException("Not implemented: cancel()");
  }

  public void clearBatch() throws SQLException
  {
    throw new SQLException("Not implemented: clearBatch()");
  }

  public void clearWarnings() throws SQLException
  {
    throw new SQLException("Not implemented: clearWarnings()");
  }

  public int[] executeBatch() throws SQLException
  {
    SQLException be  = null;
    ArrayList<Integer> rr = new ArrayList<Integer>();
    while (true) {
      try {
        if (internalExecute()) throw new SQLException("Statement attempts to return a result set","",SQLite.SQLITE_OK);
        rr.add(updateCount);
      }
      catch (SQLException e) {
        be = e;
        break;
      }
      if (sql == null) break;
      internalPrepare();
    }
    int[] result = new int[rr.size()];
    for (int i = 0; i < rr.size();  i++) result[i] = rr.get(i);
    if (be != null) {
      throw new BatchUpdateException(be.getMessage(),be.getSQLState(),be.getErrorCode(),result);
    }
    return result;
  }

  public int getFetchDirection() throws SQLException
  {
    throw new SQLException("Not implemented: getFetchDirection()");
  }

  public int getFetchSize() throws SQLException
  {
    throw new SQLException("Not implemented: getFetchSize()");
  }

  public ResultSet getGeneratedKeys() throws SQLException
  {
    List<Object[]> rows = new ArrayList<Object[]>();
    if (generatedKey != null) rows.add(new Object[] { generatedKey });
    return new ListResultSet(getGeneratedKeys_columnDefs, rows);
  }

  public int getMaxFieldSize() throws SQLException
  {
    throw new SQLException("Not implemented: getMaxFieldSize()");
  }

  public int getMaxRows() throws SQLException
  {
    throw new SQLException("Not implemented: getMaxRows()");
  }

  public boolean getMoreResults(int current) throws SQLException
  {
    throw new SQLException("Not implemented: getMoreResults(int current");
  }

  public int getQueryTimeout() throws SQLException
  {
    throw new SQLException("Not implemented:  getQueryTimeout()");
  }

  public int getResultSetConcurrency() throws SQLException
  {
    throw new SQLException("Not implemented: getResultSetConcurrency()");
  }

  public int getResultSetHoldability() throws SQLException
  {
    throw new SQLException("Not implemented: getResultSetHoldability()");
  }

  public int getResultSetType() throws SQLException
  {
    throw new SQLException("Not implemented: getResultSetType()");
  }

  public SQLWarning getWarnings() throws SQLException
  {
    throw new SQLException("Not implemented: getWarnings()");
  }

  public void setCursorName(String name) throws SQLException
  {
    throw new SQLException("Not implemented: setCursorName(String name)");
  }

  public void setFetchDirection(int direction) throws SQLException
  {
    throw new SQLException("Not implemented: setFetchDirection(int direction)");
  }

  public void setFetchSize(int rows) throws SQLException
  {
    throw new SQLException("Not implemented: setFetchSize(int rows)");
  }

  public void setMaxFieldSize(int max) throws SQLException
  {
    throw new SQLException("Not implemented: setMaxFieldSize(int max)");
  }

  public void setMaxRows(int max) throws SQLException
  {
    throw new SQLException("Not implemented: setMaxRows(int max)");
  }

  public void setQueryTimeout(int seconds) throws SQLException
  {
    throw new SQLException("Not implemented: setQueryTimeout(int seconds)");
  }

  // ***************************************************************************
  // *** Implementation of java.sql.PreparedStatement interface
  // ***************************************************************************
  public boolean execute() throws SQLException
  {
    return internalExecute();
  }

  public ResultSet executeQuery() throws SQLException
  {
    if (!internalExecute()) throw new SQLException("Not a ResultSet statement");
    return resultSet;
  }

  public int executeUpdate() throws SQLException
  {
    if (internalExecute()) throw new SQLException("Not an update statement statement");
    return updateCount;
  }

  public void setNull(int parameterIndex, int sqlType) throws SQLException
  {
    internalSetParam(parameterIndex,null,BindType.UNKNOWN);
  }

  public void setNull(int parameterIndex, int sqlType, String typeName) throws SQLException
  {
    internalSetParam(parameterIndex,null,BindType.UNKNOWN);
  }

  public void setInt(int parameterIndex, int x) throws SQLException
  {
    internalSetParam(parameterIndex,x,BindType.INT);
  }

  public void setLong(int parameterIndex, long x) throws SQLException
  {
    internalSetParam(parameterIndex,x,BindType.LONG);
  }

  public void setDate(int parameterIndex, Date x) throws SQLException
  {
    internalSetParam(parameterIndex,x,BindType.DATE);
  }

  public void setDate(int parameterIndex, Date x, Calendar cal) throws SQLException
  {
    internalSetParam(parameterIndex,x,BindType.DATE);
  }

  public void setTime(int parameterIndex, Time x) throws SQLException
  {
    internalSetParam(parameterIndex,x,BindType.DATE);
  }

  public void setTime(int parameterIndex, Time x, Calendar cal) throws SQLException
  {
    internalSetParam(parameterIndex,x,BindType.DATE);
  }

  public void setTimestamp(int parameterIndex, Timestamp x) throws SQLException
  {
    internalSetParam(parameterIndex,x,BindType.DATE);
  }

  public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal) throws SQLException
  {
    internalSetParam(parameterIndex,x,BindType.DATE);
  }

  public void setString(int parameterIndex, String x) throws SQLException
  {
    internalSetParam(parameterIndex,x,BindType.TEXT);
  }

  public void setBoolean(int parameterIndex, boolean x) throws SQLException
  {
    internalSetParam(parameterIndex,x,BindType.BOOL);
  }
  
  public void setObject(int parameterIndex, Object x) throws SQLException
  {
    BindType bt = TYPE_MAP.get(x.getClass());
    if (bt == null) throw new SQLException(String.format("Cannot convert %s",x.getClass().getName()));
    internalSetParam(parameterIndex,x,bt);
  }

  public void setObject(int parameterIndex, Object x, int targetSqlType) throws SQLException
  {
    setObject(parameterIndex, x);
  }

  public void setObject(int parameterIndex, Object x, int targetSqlType, int scale) throws SQLException
  {
    setObject(parameterIndex, x);
  }

  
  
  
  
  public void addBatch() throws SQLException
  {
    throw new SQLException("Not implemented: addBatch");
  }

  public void clearParameters() throws SQLException
  {
    throw new SQLException("Not implemented: clearParameters");
  }

  public ResultSetMetaData getMetaData() throws SQLException
  {
    throw new SQLException("Not implemented: getMetaData");
  }

  public ParameterMetaData getParameterMetaData() throws SQLException
  {
    return this;
  }

  public void setArray(int i, Array x) throws SQLException
  {
    throw new SQLException("Not implemented: setArray");
  }

  public void setAsciiStream(int parameterIndex, InputStream x, int length) throws SQLException
  {
    throw new SQLException("Not implemented: setAsciiStream");
  }

  public void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException
  {
    throw new SQLException("Not implemented: setBigDecimal");
  }

  public void setBinaryStream(int parameterIndex, InputStream x, int length) throws SQLException
  {
    throw new SQLException("Not implemented: setBinaryStream");
  }

  public void setBlob(int i, Blob x) throws SQLException
  {
    throw new SQLException("Not implemented: setBlob");
  }

  public void setByte(int parameterIndex, byte x) throws SQLException
  {
    throw new SQLException("Not implemented: setByte");
  }

  public void setBytes(int parameterIndex, byte[] x) throws SQLException
  {
    throw new SQLException("Not implemented: setBytes");
  }

  public void setCharacterStream(int parameterIndex, Reader reader, int length) throws SQLException
  {
    throw new SQLException("Not implemented: setCharacterStream");
  }

  public void setClob(int i, Clob x) throws SQLException
  {
    throw new SQLException("Not implemented: setClob");
  }

  public void setDouble(int parameterIndex, double x) throws SQLException
  {
    throw new SQLException("Not implemented: setDouble");
  }

  public void setFloat(int parameterIndex, float x) throws SQLException
  {
    throw new SQLException("Not implemented: setFloat");
  }

  public void setRef(int i, Ref x) throws SQLException
  {
    throw new SQLException("Not implemented: setRef");
  }

  public void setShort(int parameterIndex, short x) throws SQLException
  {
    throw new SQLException("Not implemented: setShort");
  }

  public void setURL(int parameterIndex, URL x) throws SQLException
  {
    throw new SQLException("Not implemented: setURL");
  }

  public void setUnicodeStream(int parameterIndex, InputStream x, int length) throws SQLException
  {
    throw new SQLException("Not implemented: setUnicodeStream");
  }
  
  public void setAsciiStream(int arg0, InputStream arg1) throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public void setAsciiStream(int arg0, InputStream arg1, long arg2) throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public void setBinaryStream(int arg0, InputStream arg1) throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public void setBinaryStream(int arg0, InputStream arg1, long arg2) throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public void setBlob(int arg0, InputStream arg1) throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public void setBlob(int arg0, InputStream arg1, long arg2) throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public void setCharacterStream(int arg0, Reader arg1) throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public void setCharacterStream(int arg0, Reader arg1, long arg2) throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public void setClob(int arg0, Reader arg1) throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public void setClob(int arg0, Reader arg1, long arg2) throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public void setNCharacterStream(int arg0, Reader arg1) throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public void setNCharacterStream(int arg0, Reader arg1, long arg2) throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public void setNClob(int arg0, Reader arg1) throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public void setNClob(int arg0, Reader arg1, long arg2) throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public void setNString(int arg0, String arg1) throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public boolean isClosed() throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public boolean isPoolable() throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public void setPoolable(boolean arg0) throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public boolean isWrapperFor(Class<?> iface) throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  public <T> T unwrap(Class<T> iface) throws SQLException
  {
    throw new SQLException("Not implemented: ");
  }

  // ***************************************************************************
  // *** Implementation of java.sql.ParameterMetaData interface
  // ***************************************************************************
  public int getParameterCount() throws SQLException
  {
    return stmt != null ? SQLite.bind_parameter_count(stmt) : 0;
  }

  public int getParameterMode(int param) throws SQLException
  {
    return ParameterMetaData.parameterModeIn;
  }

  public int isNullable(int param) throws SQLException
  {
    return ParameterMetaData.parameterNullableUnknown;
  }

  public String getParameterClassName(int param) throws SQLException
  {
    ParamDef pd = params.get(param);
    return pd != null ? pd.bindType.clazz.getName() : BindType.UNKNOWN.clazz.getName();
  }

  public int getParameterType(int param) throws SQLException
  {
    ParamDef pd = params.get(param);
    return pd != null ? pd.bindType.sqlType : BindType.UNKNOWN.sqlType;
  }

  public String getParameterTypeName(int param) throws SQLException
  {
    ParamDef pd = params.get(param);
    return pd != null ? pd.bindType.sqlTypeName : BindType.UNKNOWN.sqlTypeName;
  }

  public int getPrecision(int param) throws SQLException
  {
    throw new SQLException("Not implemented: getPrecision(int param)");
  }

  public int getScale(int param) throws SQLException
  {
    throw new SQLException("Not implemented: getScale(int param)");
  }

  public boolean isSigned(int param) throws SQLException
  {
    throw new SQLException("Not implemented: isSigned(int param)");
  }
  
  public void setNClob(int arg0, NClob arg1) throws SQLException
  {
    throw new SQLException("Not implemented: setNClob(int arg0, NClob arg1)");
  }

  public void setRowId(int arg0, RowId arg1) throws SQLException
  {
    throw new SQLException("Not implemented: setRowId(int arg0, RowId arg1");
  }

  public void setSQLXML(int arg0, SQLXML arg1) throws SQLException
  {
    throw new SQLException("Not implemented: setSQLXML(int arg0, SQLXML arg1)");
  }

  // ***************************************************************************
  // *** Private/protected methods
  // ***************************************************************************
  private void internalPrepare() throws SQLException
  {
    close();
    if (sql == null) throw new NullPointerException();
    params.clear();
    generatedKey = null;
    PointerByReference pstmt = new PointerByReference();
    PointerByReference pTail = new PointerByReference();
    try {
      connection.check(SQLite.prepare_v2(connection.handle, sql, -1, pstmt, pTail));
    } finally {
      sql = pTail.getValue().getString(0,false);
      if (sql.length() > 0) {
        int i = 1;
      }
      if (sql.length() == 0) sql = null;
      stmt = pstmt.getValue();
    }
  }

  private boolean internalExecute() throws SQLException
  {
    if (stmt == null) {
      // Handling of empty/whitespace-only statements
      resultSet = null;
      updateCount = 0;
      return false;
    }
    // Bind parameters
    for (int i = 1; i <= SQLite.bind_parameter_count(stmt); i++) {
      ParamDef pd = params.get(i);
      if (pd == null || pd.value == null) {
        connection.check(SQLite.bind_null(stmt, i));
        continue;
      }
      switch (pd.bindType) {
        case UNKNOWN:
          connection.check(SQLite.bind_null(stmt, i));
          break;
        case INT:
          connection.check(SQLite.bind_int(stmt, i, ((Integer) pd.value).intValue()));
          break;
        case BOOL:
          connection.check(SQLite.bind_int(stmt, i, ((Boolean) pd.value).booleanValue() ? 1 : 0));
          break;
        case LONG:
          connection.check(SQLite.bind_int64(stmt, i, ((Long) pd.value).longValue()));
          break;
        case DATE:
          connection.check(SQLite.bind_int64(stmt, i, ((java.util.Date) pd.value).getTime()));
          break;
        case TEXT:
          connection.check(SQLite.bind_text(stmt, i,pd.value.toString(),-1,null));
          break;
      }
      
    } 
    //Determine result type and execute as required
    boolean isResultSet = SQLite.column_count(stmt) > 0;
    if (isResultSet) {
      updateCount = -1;
      resultSet = new SQLiteResultSet(this);
    } else {
      resultSet = null;
      // Should return SQLITE_DONE;
      connection.check(SQLite.step(stmt));
      updateCount = SQLite.changes(connection.handle);
      if (fetchGeneratedKey) generatedKey = SQLite.last_insert_rowid(connection.handle);
 
    }
    return isResultSet;
  }

  private void internalSetParam(int pIndex, Object pValue, BindType pBindType)
  {
    ParamDef pd = params.get(pIndex);
    if (pd == null) {
      pd = new ParamDef();
      params.put(pIndex, pd);
    }
    pd.value = pValue;
    pd.bindType = pBindType;
  }
  
  // ***************************************************************************
  class ParamDef
  {
    Object   value;
    BindType bindType;
  }

}
